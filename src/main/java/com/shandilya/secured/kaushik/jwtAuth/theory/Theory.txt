-> JWT is a standard way for two parties to communicate securely. It is based on the open industry standard RFC 7519

-> HTTP is a stateless protocol thus for every interaction we need to contain the other supporting information to make
   the communication happen correctly. This supporting information is carried by the use tokens such as Session tokens
   or JWT Tokens.

-> Sending Session ID with Cookies works for most of the time but it can cause certain issues.
   => In the case of monolithic web application this approach works fine but in the case of the microservices this approach
      fails. Since there are multiple app servers which are sitting behind a load balancer and the request is routed to
      them. So in certain cases the request which was made to the server 1 would be lost and then when it so happens that
      the request is routed to server two then in that case the other web server may not remember the context altogether.
      To mitigate this issue a shared cache (REDIS) is introduced. But the problem with this approach is that it introduces
      a single point of failure at the redis cache. If it goes down everything goes down along with this. So to again
      mitigate this issue we introduce the concept of sticky session wherein the load balancer remembers which request
      should be routed to which web server. But the sticky session is not scalable.

   => To mitigate all the problems in the point one JWT is introduced (Json web tokens). Where the session tokens can be
      thought of as a reference token the JWT can be thought of as a value token. The JWTs are signed for the sake of
      authentication of the claim.


Structure Of JWT
==================

-> https://jwt.io/#debugger

-> The usage of base64 encoding is just for the convenience not for hiding anything
-> Anybody can take the encoded string and decode it so see the actual contents of it

The JWT consists of three parts which are base64 encoded
    . Header
      . Header tells about the algorithm being used and the token type
    . Payload
      . The actual information encoded in base64
    . Signature
      . The use of the signature is not encrypt of decrypt anything, rather it is for the server to validate if this is
        actually correct
      . HMACSHA256 is used to calculate the signature
      . Given that everyone knows what is the algorithm used to create the signature, can any one track it? No! There is
        a 256 bit secret which only the server has and thus only the server would be able to validate the signature at
        any given point of time. No one else can crack it even though the algorithm is out there in the open!

      . HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),your-256-bit-secret)
        The signature is generate using the above algorithm. HS256 is applied on the base64 encoded value of the header
        appended with . appended with the base64 encoded payload value and the 256 bit secret key. Thus the signature
        changes as and when any of the given fields either the header or the payload changes. And the secret key adds
        the 'secrecy' to it which enables the server so that only the server could verify it any given point of time

NOTE : JWTs are used for the subsequent interactions once the authentication has been done for a given entity with the
given server.

Flow of JWT generation and validation
=======================================
1. User signs with the userID and password (or with any mechanism(s) available for authentication)
2. The user is authenticated
3. If the authentication is successful then the JWT is created
4. JWT is passed back to the client by the server
5. The JWT is saved on the client side (The client may choose to store it either in the local storage or cookie)
6. JWT is passed in the header of the HTTP communication. The format is like [Authorization : Bearer <JWT>]
7. Server validates the signature
8. As part of the signature validation, the server decodes the header and payload and feeds to the signature generation
   logic along with the secret key which is owned by only the server and then at that point of time if the signature
   sent by the client in the JWT and the one generated by the server as part of the validation matches then it's certain
   that the signature is valid and the information hasn't been tampered with

Questions
============

Q). How secure is JWT ?
A). The value of the JWT is out there in the open so we shouldn't be sharing any confidential/sensitive information

Q). What is someone steals my JWT and uses it themselves ?
A). Yes it is very possible that if someone steals my JWT then they would be able to impersonate as me. So, in order to
    remove this risk we should always send JWT securely like over an HTTPS connection. Also, one very popular way of
    using JWT is to use it along with the the OAuth and OAuth comes with it's own security provisions to make sure that
    people don't steal JWTs

Q). How do you disable a JWT?
A). In the case of a session token being stolen we can invalidate the session token, but in the case of JWTs what can be
    done? Obviously we can provide the expiration time for JWTs but that's not ideal thing to do. And the JWTs can be
    blacklisted on the server, which would lead to equivalent of the JWTs being invalidated in case they are stolen. But
    it's clear that the stealing of the JWTs is a clear disadvantage of the JWTs

